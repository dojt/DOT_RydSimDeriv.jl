########################################################################
#                                                                      #
# DOT_RydSim/test/runtests.jl                                          #
#                                                                      #
# (c) Dirk Oliver Theis 2023                                           #
#                                                                      #
# License:                                                             #
#                                                                      #
#             Apache 2.0                                               #
#                                                                      #
########################################################################

# ***************************************************************************************************************************
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 0. Packages & Helpers

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 0.1. Packages

using DOT_RydSimDeriv

using Test
using JET

# using Logging

using Unitful
using Unitful: Î¼s

using LinearAlgebra: Hermitian, Diagonal, eigvecs, normalize
using Random: shuffle!

using DOT_NiceMath
using DOT_NiceMath.NumbersF64

using DOT_RydSim: is_Î´rounded


# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 2.1. Helpers

function rand_range( rg ::StepRange)
    case = rand(1:3)
    if      case == 1
        return rg.start
    elseif  case == 2
        rand(rg)
    elseif  case == 3
        return rg.stop
    end
end

function make_Pauli!( H ::Hermitian{â„‚,Matrix{â„‚}} ) :: Nothing
    let d  = size(H) |> first,
	U  = eigvecs(H),
        ğœ†âƒ—  = [  â„( (-1)^j  )    for j=1:d  ]
        shuffle!( ğœ†âƒ— )
        H .= Hermitian( Uâ‹…Diagonal(ğœ†âƒ—)â‹…U' )
    end
    nothing;
end

# ***************************************************************************************************************************
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 1. JET.jl

using JSON # Only for ignoring by JET

@testset verbose=true "Testing DOT_RydSimDeriv.jl" begin


    @testset verbose=true "JET.jl package test" begin
        #
        # Basic JET-based package test only:

        test_package(DOT_RydSimDeriv,
                     ignored_modules=(
                         AnyFrameModule(JSON.Parser) ,
                         AnyFrameModule(Base)  # This is the most idiotic line in the history of computer programs...
                                               # Why not declare vars?!  I hate millenials!
                     ) )
    end

# ***************************************************************************************************************************
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 2. Misc Tests


# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 2.2. ğ›¿ğ‘¡áµ‰á¶ á¶ 

    @testset verbose=true "Effectiv time" begin
        hw = load_hw()

        (  ; ğ‘¡áµ£â‚‘â‚›,ğ›¥ğ‘¡â‚˜áµ¢â‚™,ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,
           ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜áµ¢â‚™ğ›º,ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜â‚â‚“ğ›º, ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜áµ¢â‚™ğ›¥,ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜â‚â‚“ğ›¥,
           ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›                   ) = get_hw_data(hw)

        @test is_Î´rounded(ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜áµ¢â‚™ğ›º ; ğ›¿=ğ‘¡áµ£â‚‘â‚›)
        @test is_Î´rounded(ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜â‚â‚“ğ›º ; ğ›¿=ğ‘¡áµ£â‚‘â‚›)
        @test is_Î´rounded(ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜áµ¢â‚™ğ›¥ ; ğ›¿=ğ‘¡áµ£â‚‘â‚›)
        @test is_Î´rounded(ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜â‚â‚“ğ›¥ ; ğ›¿=ğ‘¡áµ£â‚‘â‚›)

        @test ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜áµ¢â‚™ğ›º < ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜â‚â‚“ğ›º
        @test ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜áµ¢â‚™ğ›¥ < ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜â‚â‚“ğ›¥
    end

    @testset verbose=true "Make some Î©-evolutions" begin
        hw = load_hw()

        (  ; ğ‘¡áµ£â‚‘â‚›,ğ›¥ğ‘¡â‚˜áµ¢â‚™,ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,
           ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜áµ¢â‚™ğ›º,ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜â‚â‚“ğ›º, ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜áµ¢â‚™ğ›¥,ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜â‚â‚“ğ›¥,
           ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›                    ) = get_hw_data(hw)
        (  ; ğ›º_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤,
           ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤            ) = hw

        N_ATOMS  = 3
        R_STDDEV = 64
        Îµ        = 1e-3

        Ïˆâ‚€ = randn(â„‚,2^N_ATOMS) |> normalize
        R  = let A = randn(â„‚,2^N_ATOMS,2^N_ATOMS) ; Hermitian( (A+A')â‹…R_STDDEV/2 ) end
        ğš·  = let A = randn(â„‚,2^N_ATOMS,2^N_ATOMS) ; Hermitian( (A+A')         /2 ) end
        make_Pauli!(ğš·)

        for _1iter = 1:1_000
            ğ‘¡áµ’â¿   = rand_range( (0//1)Î¼s : ğ‘¡áµ£â‚‘â‚› : 3ğ›¥ğ‘¡â‚˜áµ¢â‚™ )     ;  ğ‘¡áµ’â¿  > ğ›¥ğ‘¡â‚˜áµ¢â‚™  ||  ( ğ‘¡áµ’â¿  = ğ›¥ğ‘¡â‚˜áµ¢â‚™ )
            ğ‘¡áµ’á¶ á¶   = rand_range( ğ‘¡áµ’â¿+ğ›¥ğ‘¡â‚˜áµ¢â‚™ : ğ‘¡áµ£â‚‘â‚› : ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“ )   ;  ğ‘¡áµ’á¶ á¶  > ğ›¥ğ‘¡â‚˜áµ¢â‚™  ||  ( ğ‘¡áµ’á¶ á¶  = ğ›¥ğ‘¡â‚˜áµ¢â‚™ )
            ğ›¿ğ‘¡áµ‰á¶ á¶  = rand_range( ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜áµ¢â‚™ğ›º : ğ‘¡áµ£â‚‘â‚› : ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜â‚â‚“ğ›º/10 )
            ğ›¥     = rand_range( (0//1)/Î¼s : ğ›¥áµ£â‚‘â‚› : ğ›¥â‚˜â‚â‚“ )
            ğ‘‡     = max( ğ‘¡áµ’â¿ + ğ›¿ğ‘¡áµ‰á¶ á¶  + ğ›ºâ‚˜â‚â‚“â‹…(1/ğ›º_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤ + 1/ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤)/2 ,
                         ğ‘¡áµ’á¶ á¶  + ğ›¥/ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤                                  )

            evÎ© = Evolution_Î©( ğ‘¡áµ’â¿ , ğ›¿ğ‘¡áµ‰á¶ á¶ 
                               ; ğ›¥, Î”_ğ‘¡áµ’á¶ á¶ =ğ‘¡áµ’á¶ á¶ ,
                               Îµ, hw, ğ‘‡)
            @test true

            for _2iter = 1:100
                ğ›º = rand_range( (0//1)/Î¼s : ğ›ºáµ£â‚‘â‚› : ğ›ºâ‚˜â‚â‚“ )
                Ïˆ = copy(Ïˆâ‚€)
                evf(ğ›º, evÎ© ; ğš·,R,Ïˆ)
                @test true
            end
        end
    end

    @testset verbose=true "Make some Î”-evolutions" begin
        hw = load_hw()

        (  ; ğ‘¡áµ£â‚‘â‚›,ğ›¥ğ‘¡â‚˜áµ¢â‚™,ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,
           ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜áµ¢â‚™ğ›º,ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜â‚â‚“ğ›º, ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜áµ¢â‚™ğ›¥,ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜â‚â‚“ğ›¥,
           ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›                    ) = get_hw_data(hw)
        (  ; ğ›º_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤,
           ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤            ) = hw

        N_ATOMS  = 3
        R_STDDEV = 64
        Îµ        = 1e-3

        Ïˆâ‚€ = randn(â„‚,2^N_ATOMS) |> normalize
        R  = let A = randn(â„‚,2^N_ATOMS,2^N_ATOMS) ; Hermitian( (A+A')â‹…R_STDDEV/2 ) end
        ğš·  = let A = randn(â„‚,2^N_ATOMS,2^N_ATOMS) ; Hermitian( (A+A')         /2 ) end
        make_Pauli!(ğš·)

        for _1iter = 1:1_000
            ğ‘¡áµ’â¿   = rand_range( (0//1)Î¼s : ğ‘¡áµ£â‚‘â‚› : 3ğ›¥ğ‘¡â‚˜áµ¢â‚™ )     ;  ğ‘¡áµ’â¿  > ğ›¥ğ‘¡â‚˜áµ¢â‚™  ||  ( ğ‘¡áµ’â¿  = ğ›¥ğ‘¡â‚˜áµ¢â‚™ )
            ğ‘¡áµ’á¶ á¶   = rand_range( ğ‘¡áµ’â¿+ğ›¥ğ‘¡â‚˜áµ¢â‚™ : ğ‘¡áµ£â‚‘â‚› : ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“ )   ;  ğ‘¡áµ’á¶ á¶  > ğ›¥ğ‘¡â‚˜áµ¢â‚™  ||  ( ğ‘¡áµ’á¶ á¶  = ğ›¥ğ‘¡â‚˜áµ¢â‚™ )
            ğ›¿ğ‘¡áµ‰á¶ á¶  = rand_range( ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜áµ¢â‚™ğ›¥ : ğ‘¡áµ£â‚‘â‚› : ğ›¿ğ‘¡áµ‰á¶ á¶ â‚˜â‚â‚“ğ›¥/10 )
            ğ›º     = rand_range( (0//1)/Î¼s : ğ›ºáµ£â‚‘â‚› : ğ›ºâ‚˜â‚â‚“ )
            ğ‘‡     = max( ğ‘¡áµ’â¿ + ğ›¿ğ‘¡áµ‰á¶ á¶  + ğ›¥â‚˜â‚â‚“â‹…(1/ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤ + 1/ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤)/2 ,
                         ğ‘¡áµ’á¶ á¶  + ğ›º/ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤                                 )

            evÎ” = Evolution_Î”( ğ‘¡áµ’â¿ , ğ›¿ğ‘¡áµ‰á¶ á¶ 
                               ; ğ›º, Î©_ğ‘¡áµ’á¶ á¶ =ğ‘¡áµ’á¶ á¶ ,
                               Îµ, hw, ğ‘‡)
            @test true

            for _2iter = 1:100
                ğ›¥ = rand_range( (0//1)/Î¼s : ğ›¥áµ£â‚‘â‚› : ğ›¥â‚˜â‚â‚“ )
                Ïˆ = copy(Ïˆâ‚€)
                evf(ğ›¥, evÎ” ; ğš·,R,Ïˆ)
                @test true
            end
        end
    end

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
end #^ testset all of it

#  @testset "A broken test:" begin
#      @test DOODELDIDOO skip=true
#  end

#runtests.jl
#EOF
