# Activate .

using Revise

# Activate DOT_RydSimDeriv

using DOT_RydSim
using DOT_RydSim: Î¼s_t, Rad_per_Î¼s_t, RadperÎ¼s_per_Î¼s_t
using DOT_RydSimDeriv

# Now activate ./test/

using Test

using DOT_NiceMath
using DOT_StatsHelp
using DOT_StatsHelp.Numbers64

using LinearAlgebra: eigvals, eigvecs, Hermitian, Diagonal, normalize
using Random: shuffle!

using Unitful
using Unitful: 	Time, Frequency, Î¼s

using Zygote, UnitfulChainRules


using GenericFFT

function make_Pauli!( H ::Hermitian{â„‚,Matrix{â„‚}} ) :: Nothing
    let d  = size(H) |> first,
	U  = eigvecs(H),
        ğœ†âƒ—  = [  â„( (-1)^j  )    for j=1:d  ]
        shuffle!( ğœ†âƒ— )
        H .= Hermitian( Uâ‹…Diagonal(ğœ†âƒ—)â‹…U' )
    end
    nothing;
end

hw = load_hw(;
             Î©_downslew_factor = 1//1  #=1//3=#,
	     Î”_downslew_factor = 1//1  #=1//2=#)

N_ATOMS  = 2
R_STDDEV = 0 # 64
Îµ        = 1e-3

Ïˆâ‚€ = randn(â„‚,2^N_ATOMS) |> normalize
R  = let A = randn(â„‚,2^N_ATOMS,2^N_ATOMS) ; Hermitian( (A+A')â‹…R_STDDEV/2 ) end
ğš·  = let A = randn(â„‚,2^N_ATOMS,2^N_ATOMS) ; Hermitian( (A+A')         /2 ) end
make_Pauli!(ğš·)

println("ğœ†âƒ—(R) = ", eigvals(R) )
println("ğœ†âƒ—(ğš·) = ", eigvals(ğš·) )

#---------------------------------------------------------------------------------------
#                                                                                      -
#---------------------------------------------------------------------------------------

using Plots
plotly();

#---------------------------------------------------------------------------------------
# Pulse shape plots                                                                                     -
#---------------------------------------------------------------------------------------
plotÎ© =
let plt = plot()
    (;ğ›ºâ‚˜â‚â‚“, ğ›ºáµ£â‚‘â‚›, ğ›º_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤, Ï†áµ£â‚‘â‚›, ğ‘¡â‚˜â‚â‚“, ğ‘¡áµ£â‚‘â‚›, ğ›¥ğ‘¡â‚˜áµ¢â‚™) = hw
    (; ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ğ›º) = get_hw_data(hw)


    ğ‘¡áµ’â¿  = (0//1)Î¼s
    ğ‘¡áµ’á¶ á¶  = ğ‘¡áµ’â¿ + (25//8)ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ğ›º
    ğ‘‡    = ğ‘¡áµ’á¶ á¶  + ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ğ›º

    p = Pulse__Î©_BangBang{â„š,â„}( ğ‘¡áµ’â¿, ğ‘¡áµ’á¶ á¶ , ğ‘‡, 9//10â‹…ğ›ºâ‚˜â‚â‚“
				;   ğ›ºâ‚˜â‚â‚“, ğ›ºáµ£â‚‘â‚›,
				ğ›º_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤,
				Ï†áµ£â‚‘â‚›,
				ğ‘¡â‚˜â‚â‚“, ğ‘¡áµ£â‚‘â‚›, ğ›¥ğ‘¡â‚˜áµ¢â‚™)
    DOT_RydSim._check(p)

    plot!(plt,
	  ğ‘¡ -> p(ğ‘¡) , 0.0Î¼s: 0.0001Î¼s :ğ‘‡,
	  ; label="ğ›º",
	  color=:blue)

    um = um_parameterize(; ğ›¿ğ‘¥=ğ›ºáµ£â‚‘â‚›, ğ‘ êœ›=ğ›º_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, ğ‘ êœœ=ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤,
                         ğ›¥ğ‘¡=ğ‘¡áµ’á¶ á¶ +??????????????????????????????)

    (;xâƒ—,yâƒ—) = plotpulse(p)
    scatter!(plt,
	     xâƒ—, yâƒ—
	     ; label="",
	     color=:blue,
	     markerstrokewidth=0)
    println("Phase = $(phase(p))")

    plt
end

#---------------------------------------------------------------------------------------
# Um-Parameterization
#---------------------------------------------------------------------------------------

# from Pluto notebook "ramped-functions.jl" (in ShiftRules)
function um_parameterize(;
                        ğ›¿ğ‘¥   ::Rad_per_Î¼s_t{â„š},
                        ğ‘ êœ›   ::RadperÎ¼s_per_Î¼s_t{â„š},
                        ğ‘ êœœ   ::RadperÎ¼s_per_Î¼s_t{â„š},
                        ğ›¥ğ‘¡   ::Î¼s_t{â„š}                                # point where pulse touches 0 -- not compatible
                                                    ) ::NamedTuple

    ğ‘Ÿ = 1/ğ‘ êœ› + 1/ğ‘ êœœ

    (
        u(ğ‘¥ ::Rad_per_Î¼s_t{ğ•‚}) ::ğ•‚
    ) where{ğ•‚}                                    = ustrip(NoUnits,   ğ›¥ğ‘¡â‹…ğ‘¥ âˆ’ sign(ğ‘¥)/2 â‹… ğ‘Ÿâ‹…ğ‘¥^2   )

    (
        ğ‘¥(u ::ğ•‚) ::Rad_per_Î¼s_t{â„}
    ) where{ğ•‚}                                    = sign(u)â‹…(   ğ›¥ğ‘¡  âˆ’  âˆš( ğ›¥ğ‘¡^2 - 2ğ‘Ÿâ‹…abs(u) )   ) / ğ‘Ÿ

    (
        âˆ‚u(ğ‘¥ ::Rad_per_Î¼s_t{ğ•‚}) ::Î¼s_t{ğ•‚}
    ) where{ğ•‚}                                    = ğ›¥ğ‘¡ âˆ’ ğ‘Ÿâ‹…abs(ğ‘¥)

    (
    âˆ‚ğ‘¥(u ::ğ•‚) ::Rad_per_Î¼s_t
    ) where{ğ•‚}                                    = 1/âˆ‚u(ğ‘¥(u))

    round(ğ‘¥) = Î´round(ğ‘¥;ğ›¿=ğ›¿ğ‘¥)
    return (   ğ‘¥=roundâˆ˜ğ‘¥,   u,  âˆ‚u, âˆ‚ğ‘¥, â£ğ‘¥=ğ‘¥   )
end

# test it
@testset "Testing um-parameterization" begin
    let randâ„š()::â„š = (  num=rand(1:1_000); den=rand(num:1_000); num//den  )
        for _o_iter = 1:1
            ğ›¥ğ‘¡      = randâ„š()Î¼s
            ğ‘ êœ›      = randâ„š()/1000Î¼s^2
            ğ‘ êœœ      = randâ„š()/1000Î¼s^2
            ğ‘Ÿ       = 1/ğ‘ êœ› + 1/ğ‘ êœœ
            twor    = 2ğ‘Ÿ

            um = um_parameterize(; ğ›¿ğ‘¥=(1//1_000)/Î¼s, ğ‘ êœ›, ğ‘ êœœ, ğ›¥ğ‘¡)

            for _i_iter = 1:2
                let ğ‘¥ = rand()*2ğ›¥ğ‘¡/ğ‘Ÿ - ğ›¥ğ‘¡/ğ‘Ÿ
	            @assert -ğ›¥ğ‘¡/ğ‘Ÿ â‰¤ ğ‘¥ â‰¤ ğ›¥ğ‘¡/ğ‘Ÿ
	            u = um.u(ğ‘¥)
	            @assert -ğ›¥ğ‘¡^2/2ğ‘Ÿ â‰¤ u â‰¤ ğ›¥ğ‘¡^2/2ğ‘Ÿ
                    @test  1.0/Î¼s+ um.ğ‘¥(u)  â‰ˆ 1.0/Î¼s+ ğ‘¥             atol=1e-3/Î¼s
		    @test  1.0Î¼s+  um.âˆ‚u(ğ‘¥) â‰ˆ 1.0Î¼s+  (um.u)'(ğ‘¥)
                end
                let
		    u = ustrip(NoUnits,  rand()*2ğ›¥ğ‘¡^2/2ğ‘Ÿ âˆ’ ğ›¥ğ‘¡^2/2ğ‘Ÿ  )
		    @assert -ğ›¥ğ‘¡^2/2ğ‘Ÿ â‰¤ u â‰¤ ğ›¥ğ‘¡^2/2ğ‘Ÿ
                    ğ‘¥  = um.ğ‘¥(u)
                    @test  1.0+    um.u(ğ‘¥)  â‰ˆ 1.0+    u             atol=1e-3
		    @test  1.0/Î¼s+ um.âˆ‚ğ‘¥(u) â‰ˆ 1.0/Î¼s+ (um.â£ğ‘¥)'(u)
                end
            end
        end
    end
end

let
    global hw
	(; ğ‘¡áµ£â‚‘â‚›,ğ›¥ğ‘¡â‚˜áµ¢â‚™,ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ğ›º,  ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›) = get_hw_data(hw)

    ğ‘¡áµ’â¿  = (0//1)Î¼s
    ğ‘¡áµ’á¶ á¶  = ğ‘¡áµ’â¿ + (25//8)ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ğ›º

    um_parameterize(; ğ›¿ğ‘¥=ğ›ºáµ£â‚‘â‚›, ğ‘ êœ›=hw.ğ›º_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, ğ‘ êœœ=hw.ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤,
                    ğ›¥ğ‘¡=ğ‘¡áµ’á¶ á¶  + ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ğ›º)
end


#---------------------------------------------------------------------------------------
# Simple Plots
#---------------------------------------------------------------------------------------
plotÎ© =
let
    global hw
	(; ğ‘¡áµ£â‚‘â‚›,ğ›¥ğ‘¡â‚˜áµ¢â‚™,ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ğ›º,  ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›) = get_hw_data(hw)

    ğ‘¡áµ’â¿  = (0//1)Î¼s
    ğ‘¡áµ’á¶ á¶  = ğ‘¡áµ’â¿ + (25//8)ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ğ›º
    ğ‘‡    = ğ‘¡áµ’á¶ á¶  + ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ğ›º
    evÎ© = Evolution_Î©( ğ‘¡áµ’â¿ , ğ‘¡áµ’á¶ á¶ 
                      ; ğ›¥ = (0//1)/Î¼s#=ğ›¥â‚˜â‚â‚“=#, Îµ, hw ,
                       ğ‘‡)

    ğ‘“(ğ›º) = let Ïˆ = copy(Ïˆâ‚€)
               evf(ğ›º, evÎ© ; ğš·,R,Ïˆ)
           end

    plt1 = scatter( ğ›º -> ğ‘“(ğ›º),
                    -ğ›ºâ‚˜â‚â‚“: 7ğ›ºáµ£â‚‘â‚› :+ğ›ºâ‚˜â‚â‚“
	            ; label="",
                    color=:blue,
	            markersize=0.5, markerstrokewidth=0,
	            xaxis="ğ›º")

    um = um_parameterize(; ğ›¿ğ‘¥=ğ›ºáµ£â‚‘â‚›, ğ‘ êœ›=hw.ğ›º_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, ğ‘ êœœ=hw.ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤,
                         ğ›¥ğ‘¡=ğ‘‡)
    plt2 = scatter(u -> ğ‘“(um.ğ‘¥(u)),
                    um.u(-ğ›ºâ‚˜â‚â‚“): 0.01 :um.u(+ğ›ºâ‚˜â‚â‚“)
	            ; label="",
                    color=:red,
	            markersize=0.5, markerstrokewidth=0,
	            xaxis="u(ğ›º)")
    (plt1,plt2)
end

plotÎ” =
let
    global hw
    (; ğ‘¡áµ£â‚‘â‚›,ğ›¥ğ‘¡â‚˜áµ¢â‚™,ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,  ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›) = get_hw_data(hw)

    ğ›º   = -ğ›ºâ‚˜â‚â‚“/100
    ğ‘¡áµ’â¿  = max(ğ›¥ğ‘¡â‚˜áµ¢â‚™, 10â‹…ğ‘¡áµ£â‚‘â‚›)
    ğ‘¡áµ’á¶ á¶  = min( 10000â‹…ğ‘¡áµ£â‚‘â‚›,
                ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“ - get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º(hw;ğ›º,ğ›¥=ğ›¥â‚˜â‚â‚“))

    @show ğ‘¡áµ’â¿,ğ‘¡áµ’á¶ á¶ ,ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“


    evÎ” = Evolution_Î”( ğ‘¡áµ’â¿ , ğ‘¡áµ’á¶ á¶ 
                      ; ğ›º, Îµ, hw )

    scatter( ğ›¥ -> let Ïˆ = copy(Ïˆâ‚€)
                evf(ğ›¥, evÎ” ; ğš·,R,Ïˆ)
             end,
             -ğ›¥â‚˜â‚â‚“: 100001ğ›¥áµ£â‚‘â‚› :+ğ›¥â‚˜â‚â‚“
	     ;
             label="",
	     markersize=0.5, markerstrokewidth=0,
	     xaxis="ğ›¥")
end

#---------------------------------------------------------------------------------------
# Fourier Transform
#---------------------------------------------------------------------------------------

plotÎ©_fÌ‚ =
let
    global hw
    (; ğ‘¡áµ£â‚‘â‚›,ğ›¥ğ‘¡â‚˜áµ¢â‚™,ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“, ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ğ›º,  ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›) = get_hw_data(hw)

    ğ‘¡áµ’â¿  = (0//1)Î¼s
    ğ‘¡áµ’á¶ á¶  = ğ‘¡áµ’â¿ + (25//8)ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ğ›º
    evÎ©  = Evolution_Î©( ğ‘¡áµ’â¿ , ğ‘¡áµ’á¶ á¶ 
                        ;
                        ğ›¥ = ğ›¥â‚˜â‚â‚“, Îµ=0.001, hw,
                        ğ‘‡ = ğ‘¡áµ’á¶ á¶  + ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ğ›º )

    Set_of_ğ›ºs = (  -ğ›ºâ‚˜â‚â‚“: 100ğ›ºáµ£â‚‘â‚› :+ğ›ºâ‚˜â‚â‚“  )
    N = length(Set_of_ğ›ºs)
    fâƒ— = [ let Ïˆ = copy(Ïˆâ‚€)
             evf(ğ›º, evÎ© ; ğš·,R,Ïˆ)
          end
          for ğ›º âˆˆ Set_of_ğ›ºs       ]

    fÌ‚ = fft(fâƒ—) ./ N

    Î©â‚˜â‚â‚“ = ustrip(u"Î¼s^(-1)", ğ›ºâ‚˜â‚â‚“)
    scatter(  [ ( k==0 ? 0.0 : 2Ï€/(2Î©â‚˜â‚â‚“/k) )   for k = 0:length(fÌ‚)Ã·2 ],
              abs.(@view fÌ‚[1:1+length(fÌ‚)Ã·2])
              ; label="",
              color=:blue,
	      markersize=0.5, markerstrokewidth=0 )

    Î» = DOT_RydSimDeriv.Î»(evÎ©)
    K = 2Ï€/Î»
    scatter!([K],[0.0]
             ; label="",
             color=:red,
	     markersize=1, markerstrokewidth=0 )
end

plotÎ”_fÌ‚ =
let
    global hw
    (; ğ‘¡áµ£â‚‘â‚›,ğ›¥ğ‘¡â‚˜áµ¢â‚™,ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,  ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›) = get_hw_data(hw)

    ğ›º   = ğ›ºâ‚˜â‚â‚“/10
    ğ‘¡áµ’â¿  = max(ğ›¥ğ‘¡â‚˜áµ¢â‚™, 10â‹…ğ‘¡áµ£â‚‘â‚›)
    ğ‘¡áµ’á¶ á¶  = min(       10000â‹…ğ‘¡áµ£â‚‘â‚›, ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“- get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º(hw;ğ›º,ğ›¥=ğ›¥â‚˜â‚â‚“))
    evÎ”  = Evolution_Î”( ğ‘¡áµ’â¿ , ğ‘¡áµ’á¶ á¶ 
                        ; ğ›º, Îµ=1e-4, hw )

    Set_of_ğ›¥s = (   ğ›¥áµ£â‚‘â‚›â‹… ğ›¥  for ğ›¥ âˆˆ range(start=-ğ›¥â‚˜â‚â‚“/ğ›¥áµ£â‚‘â‚›, stop=+ğ›¥â‚˜â‚â‚“/ğ›¥áµ£â‚‘â‚›, length=5001)   )
    N = length(Set_of_ğ›¥s)
    fâƒ— = [ let Ïˆ = copy(Ïˆâ‚€)
             evf(ğ›¥, evÎ” ; ğš·,R,Ïˆ)
          end
          for ğ›¥ âˆˆ Set_of_ğ›¥s       ]

    fÌ‚ = fft(fâƒ—) ./ N

    ğ›¥â‚˜â‚â‚“ = ustrip(u"Î¼s^(-1)", ğ›¥â‚˜â‚â‚“)
    scatter(  [ ( k==0 ? 0.0 : 2Ï€/(2ğ›¥â‚˜â‚â‚“/k) )   for k = 0:length(fÌ‚)Ã·2 ],
              abs.(@view fÌ‚[1:1+length(fÌ‚)Ã·2])
              ; label="",
              color=:blue,
	      markersize=0.5, markerstrokewidth=0 )

    Î» = DOT_RydSimDeriv.Î»(evÎ”)
    K = 2Ï€/Î»
    scatter!([K],[0.0]
             ; label="",
             color=:red,
	     markersize=1, markerstrokewidth=0 )
end

#EOF
