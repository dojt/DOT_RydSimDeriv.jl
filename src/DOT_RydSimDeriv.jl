########################################################################
#                                                                      #
# DOT_RydSimDeriv.jl                                                   #
#                                                                      #
# (c) Dirk Oliver Theis 2023                                           #
#                                                                      #
# License:                                                             #
#                                                                      #
#             Apache 2.0                                               #
#                                                                      #
########################################################################

# ***************************************************************************************************************************
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 0. ToC  +
#                                                                                                             |
#  Table of Contents                                                                                          |
#  -----------------                                                                                          |
#                                                                                                             |
#    1.  Module header & imports                                                                              |
#                                                                                                             |
#        1.1.  Exports                                                                                        |
#        1.2.  Imports                                                                                        |
#                                                                                                             |
#                                                                                                             |
#    2.  Interface to lower level (RydSim)                                                                    |
#                                                                                                             |
#        2.1.  `load_hw()`                                                                                    |
#        2.2.  `get_hw_data()`                                                                                |
#        2.3.  `get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º()`                                                                         |
#                                                                                                             |
#                                                                                                             |
#    3.  Evolutions                                                                                           |
#                                                                                                             |
#        3.1.  Î© Evolution                                                                                    |
#              3.1.a. Î© Constructor                                                                           |
#              3.1.b. Î© Callable                                                                              |
#                                                                                                             |
#        3.2.  Î” Evolution                                                                                    |
#              3.2.a. Î” Constructor                                                                           |
#              3.2.b. Î” Callable                                                                              |
#                                                                                                             |
#                                                                                                             |
#    4.  EVF â€” Expectation Value Function                                                                     |
#                                                                                                             |
#    5.  ..............                                                                                       |
#                                                                                                             |
#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”+

# ******************************************************************************************************************************
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 1. Module header & imports

"""
Module `DOT_RydSimDeriv`

Build on top of package `DOT_RydSim` to provide functionality to run the type of quantum evolutions
that are used in derivatives based on shift rules such as symmetric difference quotients,
Banchi-Crooks's "stochastic" shift rules, and the "Nyquist" shift rules.

# Exports

### Interface with lower stack

* Function [`load_hw`](@ref)`()` â€” load hardware configuration from file
* Functions [`get_hw_data`](@ref)`()`, [`get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º`](@ref)`()` â€” extract hw data

### Defining and evaluation EVFs

EVF = Expectation Value Function

* Types with constructors [`Evolution_Î©`](@ref), [`Evolution_Î”`](@ref).



"""
module DOT_RydSimDeriv

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 1.1. Exports
export load_hw
export get_hw_data, get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º
export evf_Î©, evf_Î©

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 1.1. Imports
using DOT_NiceMath
using DOT_NiceMath.NumbersF64

using DOT_RydSim
using DOT_RydSim:
    Î¼s_t,
    Rad_per_Î¼s_t


using DOT_RydSim.HW_Descriptions:
    HW_Descr,
	default_HW_Descr,
	fileread_HW_Descr,
	HW_AWS_QuEra


using Unitful: Î¼s
using LinearAlgebra: Hermitian


# ******************************************************************************************************************************
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 2. Interface to lower level

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 2.1. load_hw()
"""
Function
```julia
load_hw(filename = :default
		; Î©_downslew_factor = 1//1,
		  Î”_downslew_factor = 1//1  ) ::HW_Descr
```

The `filename` can be either a string identifying a file name, or the symbol `:default`.

The only file type currently supported is AWS-QuEra's (`HW_AWS_QuEra`).
"""
function load_hw(filename ::String
				;
				Î©_downslew_factor = 1//1,
				Î”_downslew_factor = 1//1              ) ::HW_Descr{â„š}

	return fileread_HW_Descr(HW_AWS_QuEra
							;   filename,
								â„¤,
								Î©_downslew_factor,
								Î”_downslew_factor )
end

function load_hw(select ::Symbol =:default
				;
				Î©_downslew_factor = 1//1,
				Î”_downslew_factor = 1//1              ) ::HW_Descr{â„š}

	@assert select == :default  "What?!??"
	return default_HW_Descr(;
							â„¤,
							Î©_downslew_factor,
							Î”_downslew_factor)
end

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 2.2. get_hw_data()

_NT = @NamedTuple{
				_blah::Nothing,
				ğ›ºâ‚˜â‚â‚“        ::Rad_per_Î¼s_t{â„š},
				ğ›ºáµ£â‚‘â‚›        ::Rad_per_Î¼s_t{â„š},
				ğ›¥â‚˜â‚â‚“        ::Rad_per_Î¼s_t{â„š}, ğ›¥áµ£â‚‘â‚›::Rad_per_Î¼s_t{â„š},
				ğ‘¡áµˆáµ’Ê·â¿       ::Î¼s_t{â„š},
				ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“     ::Î¼s_t{â„š},
				ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ ::Î¼s_t{â„š},
				ğ‘¡áµ£â‚‘â‚›        ::Î¼s_t{â„š},
				ğ‘¡â‚˜â‚â‚“        ::Î¼s_t{â„š}
		}

@doc raw"""
Function `get_hw_data(::HW_Descr) ::NamedTuple`

Returns a named tuple with the following fields, all of
unitful rational number types:
* `ğ›ºâ‚˜â‚â‚“`, `ğ›ºáµ£â‚‘â‚›`;
* `ğ›¥â‚˜â‚â‚“` `ğ›¥áµ£â‚‘â‚›`;
* `ğ‘¡áµ£â‚‘â‚›`;
* `ğ‘¡â‚˜â‚â‚“`           â€” max total evolution time
* `ğ‘¡áµˆáµ’Ê·â¿`          â€” time needed between ğ‘¡áµ’á¶ á¶  and EOEv to allow for 
  full range of ğ›º and ğ›¥.
* `ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“`        â€” largest switch-off time which allows full range of ğ›º and ğ›¥
* `ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™`    â€” smallest duration ``t^{\text{off}}-t^{\text{on}}``
  which allows full range of ğ›º and ğ›¥
"""
function get_hw_data(hw ::HW_Descr{â„š}) ::_NT

	( ; ğ›ºâ‚˜â‚â‚“, ğ›ºáµ£â‚‘â‚›, ğ›º_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤, Ï†áµ£â‚‘â‚›,
		ğ›¥â‚˜â‚â‚“, ğ›¥áµ£â‚‘â‚›, ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤,
		ğ‘¡â‚˜â‚â‚“, ğ‘¡áµ£â‚‘â‚›, ğ›¥ğ‘¡â‚˜áµ¢â‚™                               ) = hw

	ğ›º_ğ‘¢ğ‘ğ‘¡ğ‘–ğ‘šğ‘’ = ğ›ºâ‚˜â‚â‚“ / ğ›º_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤ ; ğ›º_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘¡ğ‘–ğ‘šğ‘’ = ğ›ºâ‚˜â‚â‚“ / ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤
	ğ›¥_ğ‘¢ğ‘ğ‘¡ğ‘–ğ‘šğ‘’ = ğ›¥â‚˜â‚â‚“ / ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤ ; ğ›¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘¡ğ‘–ğ‘šğ‘’ = ğ›¥â‚˜â‚â‚“ / ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤

    ğ‘¡áµˆáµ’Ê·â¿ = Î´round_up(   max(ğ›º_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘¡ğ‘–ğ‘šğ‘’,
			                 ğ›¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘¡ğ‘–ğ‘šğ‘’);
			             ğ›¿=ğ‘¡áµ£â‚‘â‚› )

	return (_blah=nothing,
			ğ›ºâ‚˜â‚â‚“, ğ›ºáµ£â‚‘â‚›,
			ğ›¥â‚˜â‚â‚“, ğ›¥áµ£â‚‘â‚›,
            ğ‘¡áµˆáµ’Ê·â¿,
			ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“     = ğ‘¡â‚˜â‚â‚“ - ğ‘¡áµˆáµ’Ê·â¿,
			ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ = Î´round_up(
							max( ğ›º_ğ‘¢ğ‘ğ‘¡ğ‘–ğ‘šğ‘’,
								 ğ›¥_ğ‘¢ğ‘ğ‘¡ğ‘–ğ‘šğ‘’,
								 ğ›¥ğ‘¡â‚˜áµ¢â‚™);
							ğ›¿=ğ‘¡áµ£â‚‘â‚›),
			ğ‘¡áµ£â‚‘â‚›, ğ‘¡â‚˜â‚â‚“)
end

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 2.3. get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º()

@doc raw"""
Function `get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º(hw::HW_Descr ;  ğ›º =hw.ğ›ºâ‚˜â‚â‚“, ğ›¥ =hw.ğ›¥â‚˜â‚â‚“) `

ğ›º-pulse must end this quantity *later* than ğ›¥-pulse in order not to break the RWA with max ğ›º,ğ›¥
"""
function
get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º( hw ::HW_Descr{â„š}
					;
					ğ›º :: Rad_per_Î¼s_t{â„š} = hw.ğ›ºâ‚˜â‚â‚“,
					ğ›¥ :: Rad_per_Î¼s_t{â„š} = hw.ğ›¥â‚˜â‚â‚“ ) ::Î¼s_t{â„š}

	( ; ğ›ºâ‚˜â‚â‚“, ğ›ºáµ£â‚‘â‚›, ğ›º_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤, Ï†áµ£â‚‘â‚›,
		ğ›¥â‚˜â‚â‚“, ğ›¥áµ£â‚‘â‚›, ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤,
		ğ‘¡â‚˜â‚â‚“, ğ‘¡áµ£â‚‘â‚›, ğ›¥ğ‘¡â‚˜áµ¢â‚™                               ) = hw

	ğ›º = abs(ğ›º)
	ğ›¥ = abs(ğ›¥)
	@assert ğ›º > 0/Î¼s

	ğ›º_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘¡ğ‘–ğ‘šğ‘’ = ğ›º / ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤
	ğ›¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘¡ğ‘–ğ‘šğ‘’ = ğ›¥ / ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤

	return Î´round_up( max((0//1)Î¼s, ğ›¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘¡ğ‘–ğ‘šğ‘’ - ğ›º_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘¡ğ‘–ğ‘šğ‘’ )
					  ; ğ›¿=ğ‘¡áµ£â‚‘â‚›)
end

# ******************************************************************************************************************************
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 3. Evolutions

abstract type Evolution_t end

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 3.1. Î© Evolution

@kwdef struct Evolution_Î© <: Evolution_t
    pÎ”     :: Pulse__Î”_BangBang{â„š}

    ğ‘¡â‚€     ::Î¼s_t{â„š}
	Î©_ğ‘¡áµ’â¿  ::Î¼s_t{â„š}
    Î©_ğ‘¡áµ’á¶ á¶  ::Î¼s_t{â„š}
	ğ‘‡      ::Î¼s_t{â„š}

    Îµ      ::â„

	hw     ::HW_Descr
end

# -      -      -      -      -      -      -      -      -      -      -      -      -      -      - 3.1.a. Î© Constructor
@doc raw"""
Constructor
```julia
Evolution_Î©( ğ‘¡áµ’â¿  ::Î¼s_t{â„š},
             ğ‘¡áµ’á¶ á¶  ::Î¼s_t{â„š}
             ;
             ğ›¥    ::Rad_per_Î¼s_t,
             Îµ    ::â„,
             hw   ::HW_Descr,
             ğ‘‡    ::Î¼s_t{â„š}     = ...)   ::Evolution_Î©
```

Creates evolution data for variable ğ›º, with fixed ğ›¥, starting at time ğ‘¡áµ’â¿, and ending at time ğ‘‡.

A lower bound for the end-time ğ‘‡ of the evolution is ğ‘¡áµ’á¶ á¶  + ğ‘¡áµˆáµ’Ê·â¿; an upper bound is ğ‘¡â‚˜â‚â‚“.

Lower bounds for ğ‘¡áµ’á¶ á¶ -ğ‘¡áµ’â¿ are ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ and ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º; an upper bound for ğ‘¡áµ’á¶ á¶  is ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“.

The quantities mentioned above are defined in the named tuple returned by
[`get_hw_data`](@ref)`()`, except for ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º, which is returned by
[`get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º`](@ref)`()`.
"""
function Evolution_Î©( ğ‘¡áµ’â¿  ::Î¼s_t{â„š},
                      ğ‘¡áµ’á¶ á¶  ::Î¼s_t{â„š}
                      ;
                      ğ›¥  ::Rad_per_Î¼s_t,
                      Îµ  ::â„,
                      hw ::HW_Descr,
                      ğ‘‡  ::Î¼s_t{â„š}     =
                          ğ‘¡áµ’á¶ á¶  +
                          # ;
                          get_hw_data(hw).ğ‘¡áµˆáµ’Ê·â¿             )   ::Evolution_Î©

	(; ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›, ğ‘¡áµˆáµ’Ê·â¿,ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™, ğ‘¡áµ£â‚‘â‚›,ğ‘¡â‚˜â‚â‚“) =
        get_hw_data(hw)
    ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º =
        get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º(hw;ğ›º=ğ›ºâ‚˜â‚â‚“, ğ›¥)

    #
    # Check args
    #
    ğ‘¡áµ’â¿  == Î´round_down( ğ‘¡áµ’â¿ ;ğ›¿=hw.ğ‘¡áµ£â‚‘â‚›)  || throw(ArgumentError(
                                             "ğ‘¡áµ’â¿ must be multiple of HW ğ‘¡áµ£â‚‘â‚›"))
    ğ‘¡áµ’á¶ á¶  == Î´round_down( ğ‘¡áµ’á¶ á¶  ;ğ›¿=hw.ğ‘¡áµ£â‚‘â‚›) || throw(ArgumentError(
                                             "ğ‘¡áµ’á¶ á¶  must be multiple of HW ğ‘¡áµ£â‚‘â‚›"))
    ğ‘‡    == Î´round_down( ğ‘‡ ;ğ›¿=hw.ğ‘¡áµ£â‚‘â‚›)    || throw(ArgumentError(
                                             "ğ‘‡ must be multiple of HW ğ‘¡áµ£â‚‘â‚›"))
    ğ‘¡áµ’â¿ + ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ â‰¤ ğ‘¡áµ’á¶ á¶               || throw(ArgumentError(
                                             "ğ‘¡áµ’á¶ á¶ -ğ‘¡áµ’â¿ must be â‰¥ ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™"))
    ğ‘¡áµ’â¿ + ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º â‰¤ ğ‘¡áµ’á¶ á¶               || throw(ArgumentError(
                                             "ğ‘¡áµ’á¶ á¶ -ğ‘¡áµ’â¿ must be â‰¥ ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º"))
    ğ‘¡áµ’á¶ á¶  â‰¤ ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“                        || throw(ArgumentError(
                                             "Need ğ‘¡áµ’á¶ á¶  â‰¤ ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“"))
    ğ‘‡ â‰¤ ğ‘¡â‚˜â‚â‚“                              || throw(ArgumentError(
                                             "Need ğ‘‡ â‰¤ ğ‘¡â‚˜â‚â‚“"))
    ğ‘¡áµ’á¶ á¶  + ğ‘¡áµˆáµ’Ê·â¿ â‰¤ ğ‘‡                      || throw(ArgumentError(
                                             "Need ğ‘‡ â‰¥ ğ‘¡áµ’á¶ á¶  + ğ‘¡áµˆáµ’Ê·â¿"))
    #
    # Make Î” pulse
    #
	Î”_ğ‘¡áµ’â¿  = ğ‘¡áµ’â¿
    Î”_ğ‘¡áµ’á¶ á¶  = ğ‘¡áµ’á¶ á¶  - ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º

	pÎ” = Pulse__Î”_BangBang{â„š}(Î”_ğ‘¡áµ’â¿, Î”_ğ‘¡áµ’á¶ á¶ , ğ‘‡, ğ›¥
							  ;  hw.ğ›¥â‚˜â‚â‚“, hw.ğ›¥áµ£â‚‘â‚›,
							     hw.ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, hw.ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤,
                                 # ;
								 hw.ğ‘¡â‚˜â‚â‚“, hw.ğ‘¡áµ£â‚‘â‚›, hw.ğ›¥ğ‘¡â‚˜áµ¢â‚™)
	DOT_RydSim._check(pÎ”)

    #
    # Construct it:
    #
    Evolution_Î©(;pÎ”,
                Î©_ğ‘¡áµ’â¿  = ğ‘¡áµ’â¿,
                Î©_ğ‘¡áµ’á¶ á¶  = ğ‘¡áµ’á¶ á¶ ,
                ğ‘¡â‚€     = min(ğ‘¡áµ’â¿, Î”_ğ‘¡áµ’â¿),
                ğ‘‡,
                Îµ,
                hw)
end #^ Evolution_Î©()

# -      -      -      -      -      -      -      -      -      -      -      -      -      -      - 3.1.b. Î© Callable
function (ev::Evolution_Î©)(ğ›º ::Rad_per_Î¼s_t{â„š}
                           ;
                           Ï• ::Vector{â„‚},
                           R ::Hermitian{â„‚,Matrix{â„‚}},
                           Ïˆ ::Vector{â„‚}              ) ::â„‚

    @assert length(Ï•) == length(Ïˆ)
    @assert ( length(Ï•) , length(Ïˆ) ) == size(R)


	(; ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›) = get_hw_data(ev.hw)
	# (; ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›, ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™) = get_hw_info(hw)

	pÎ© = Pulse__Î©_BangBang{â„š,â„}(ev.Î©_ğ‘¡áµ’â¿, ev.Î©_ğ‘¡áµ’á¶ á¶ , ev.ğ‘‡,
                                ğ›º
								;   hw.ğ›ºâ‚˜â‚â‚“, hw.ğ›ºáµ£â‚‘â‚›,
									hw.ğ›º_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, hw.ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤,
									hw.Ï†áµ£â‚‘â‚›,
									hw.ğ‘¡â‚˜â‚â‚“, hw.ğ‘¡áµ£â‚‘â‚›, hw.ğ›¥ğ‘¡â‚˜áµ¢â‚™)
	DOT_RydSim._check(pÎ©)


	Ïˆáµ¤â‚›â‚‘ = copy(Ïˆ)

	schrÃ¶d!(  Ïˆáµ¤â‚›â‚‘, â„(ev.ğ‘‡)
			  ;
              ğ‘¡â‚€ = ev.ğ‘¡â‚€,
              Î©  = pÎ©,
			  Î”  = ev.pÎ”,
			  R,
			  Îµ )

	return Ï•' â‹… Ïˆáµ¤â‚›â‚‘
end

# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 3.2. Î” Evolution

@kwdef struct Evolution_Î” <: Evolution_t
    pÎ©     :: Pulse__Î©_BangBang{â„š,â„}

    ğ‘¡â‚€     ::Î¼s_t{â„š}
	Î”_ğ‘¡áµ’â¿  ::Î¼s_t{â„š}
    Î”_ğ‘¡áµ’á¶ á¶  ::Î¼s_t{â„š}
	ğ‘‡      ::Î¼s_t{â„š}

    Îµ      ::â„

	hw     ::HW_Descr
end

# -      -      -      -      -      -      -      -      -      -      -      -      -      -      - 3.2.a. Î” Constructor
@doc raw"""
Constructor
```julia
Evolution_Î”( ğ‘¡áµ’â¿  ::Î¼s_t{â„š},
             ğ‘¡áµ’á¶ á¶  ::Î¼s_t{â„š}
             ;
             ğ›º    ::Rad_per_Î¼s_t,
             Îµ    ::â„,
             hw   ::HW_Descr,
             ğ‘‡    ::Î¼s_t{â„š}     = ...)   ::Evolution_Î©
```

Creates evolution data for variable ğ›¥, with fixed ğ›º, starting at time ğ‘¡áµ’â¿, and ending at time ğ‘‡.

A lower bound for the end-time ğ‘‡ of the evolution is ğ‘¡áµ’á¶ á¶  + ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º + ğ‘¡áµˆáµ’Ê·â¿; an upper bound is
ğ‘¡â‚˜â‚â‚“.

A lower bound for ğ‘¡áµ’á¶ á¶  is ğ‘¡áµ’â¿ + ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™; an upper bound is ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“.

The quantities mentioned above are defined in the named tuple returned by
[`get_hw_data`](@ref)`()`, except for ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º, which is returned by
[`get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º`](@ref)`()`.
"""
function Evolution_Î”( ğ‘¡áµ’â¿  ::Î¼s_t{â„š},
                      ğ‘¡áµ’á¶ á¶  ::Î¼s_t{â„š}
                      ;
                      ğ›º   ::Rad_per_Î¼s_t,
                      Îµ   ::â„,
                      hw  ::HW_Descr,
                      ğ‘‡   ::Î¼s_t{â„š}     =
                          ğ‘¡áµ’á¶ á¶  +
                          get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º(hw;ğ›º, ğ›¥=ğ›¥â‚˜â‚â‚“) +
                          get_hw_data(hw).ğ‘¡áµˆáµ’Ê·â¿             )   ::Evolution_Î”

	(; ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›, ğ‘¡áµˆáµ’Ê·â¿,ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™, ğ‘¡áµ£â‚‘â‚›,ğ‘¡â‚˜â‚â‚“) =
        get_hw_data(hw)
    ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º =
        get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º(hw;ğ›º, ğ›¥=ğ›¥â‚˜â‚â‚“)

    #
    # Check args
    #
    ğ‘¡áµ’â¿  == Î´round_down( ğ‘¡áµ’â¿ ;ğ›¿=hw.ğ‘¡áµ£â‚‘â‚›)  || throw(ArgumentError(
                                             "ğ‘¡áµ’â¿ must be multiple of HW ğ‘¡áµ£â‚‘â‚›"))
    ğ‘¡áµ’á¶ á¶  == Î´round_down( ğ‘¡áµ’á¶ á¶  ;ğ›¿=hw.ğ‘¡áµ£â‚‘â‚›) || throw(ArgumentError(
                                             "ğ‘¡áµ’á¶ á¶  must be multiple of HW ğ‘¡áµ£â‚‘â‚›"))
    ğ‘‡    == Î´round_down( ğ‘‡ ;ğ›¿=hw.ğ‘¡áµ£â‚‘â‚›)    || throw(ArgumentError(
                                             "ğ‘‡ must be multiple of HW ğ‘¡áµ£â‚‘â‚›"))
    ğ‘¡áµ’â¿ + ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™ â‰¤ ğ‘¡áµ’á¶ á¶               || throw(ArgumentError(
                                             "ğ‘¡áµ’á¶ á¶ -ğ‘¡áµ’â¿ must be â‰¥ ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™"))
    # ;
    # ;
    ğ‘¡áµ’á¶ á¶  â‰¤ ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“                        || throw(ArgumentError(
                                             "Need ğ‘¡áµ’á¶ á¶  â‰¤ ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“"))
    ğ‘‡ â‰¤ ğ‘¡â‚˜â‚â‚“                              || throw(ArgumentError(
                                             "Need ğ‘‡ â‰¤ ğ‘¡â‚˜â‚â‚“"))
    ğ‘¡áµ’á¶ á¶  + ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º  + ğ‘¡áµˆáµ’Ê·â¿ â‰¤ ğ‘‡       || throw(ArgumentError(
                                             "Need ğ‘‡ â‰¥ ğ‘¡áµ’á¶ á¶  + ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º + ğ‘¡áµˆáµ’Ê·â¿"))
    #
    # Make Î© pulse
    #
    Î©_ğ‘¡áµ’â¿  = ğ‘¡áµ’â¿
    Î©_ğ‘¡áµ’á¶ á¶  = ğ‘¡áµ’á¶ á¶  + get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º(hw;ğ›º, ğ›¥=ğ›¥â‚˜â‚â‚“)

	pÎ© = Pulse__Î©_BangBang{â„š,â„}(Î©_ğ‘¡áµ’â¿, Î©_ğ‘¡áµ’á¶ á¶ , ğ‘‡, ğ›º
								;   hw.ğ›ºâ‚˜â‚â‚“, hw.ğ›ºáµ£â‚‘â‚›,
									hw.ğ›º_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, hw.ğ›º_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤,
									hw.Ï†áµ£â‚‘â‚›,
									hw.ğ‘¡â‚˜â‚â‚“, hw.ğ‘¡áµ£â‚‘â‚›, hw.ğ›¥ğ‘¡â‚˜áµ¢â‚™)
	DOT_RydSim._check(pÎ©)

    #
    # Construct it:
    #
    Evolution_Î”(;pÎ©,
                Î”_ğ‘¡áµ’â¿  = ğ‘¡áµ’â¿,
                Î”_ğ‘¡áµ’á¶ á¶  = ğ‘¡áµ’á¶ á¶ ,
                ğ‘¡â‚€     = min(ğ‘¡áµ’â¿, Î”_ğ‘¡áµ’â¿),
                ğ‘‡,
                Îµ,
                hw)
end #^ Evolution_Î”()

# -      -      -      -      -      -      -      -      -      -      -      -      -      -      - 3.2.b. Î” Callable
function (ev::Evolution_Î”)(ğ›¥ ::Rad_per_Î¼s_t{â„š}
                           ;
                           Ï• ::Vector{â„‚},
                           R ::Hermitian{â„‚,Matrix{â„‚}},
                           Ïˆ ::Vector{â„‚}              ) ::â„‚

    @assert length(Ï•) == length(Ïˆ)
    @assert ( length(Ï•) , length(Ïˆ) ) == size(R)


	(; ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›) = get_hw_data(ev.hw)
	# (; ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›, ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™) = get_hw_info(hw)

	pÎ” = Pulse__Î”_BangBang{â„š}(ev.Î”_ğ‘¡áµ’â¿, ev.Î”_ğ‘¡áµ’á¶ á¶ , ev.ğ‘‡,
                              ğ›¥
							  ;   hw.ğ›¥â‚˜â‚â‚“, hw.ğ›¥áµ£â‚‘â‚›,
							      hw.ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘¢ğ‘ğ‘ ğ‘™ğ‘’ğ‘¤, hw.ğ›¥_ğ‘šğ‘ğ‘¥_ğ‘‘ğ‘œğ‘¤ğ‘›ğ‘ ğ‘™ğ‘’ğ‘¤,
							      hw.ğ‘¡â‚˜â‚â‚“, hw.ğ‘¡áµ£â‚‘â‚›, hw.ğ›¥ğ‘¡â‚˜áµ¢â‚™)
	DOT_RydSim._check(pÎ”)


	Ïˆáµ¤â‚›â‚‘ = copy(Ïˆ)

	schrÃ¶d!(  Ïˆáµ¤â‚›â‚‘, â„(ev.ğ‘‡)
			  ;
              ğ‘¡â‚€ = ev.ğ‘¡â‚€,
			  Î”  = pÎ”,
              Î©  = ev.pÎ©,
			  R,
			  Îµ )

	return Ï•' â‹… Ïˆáµ¤â‚›â‚‘
end

# ******************************************************************************************************************************
# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 4. EVF

@doc raw"""
Function
```julia
    evf(ğ‘¥  ::Rad_per_Î¼s_t{â„š},
        ev ::EVO
        ;
        Ï• ::Vector{â„‚},
        R ::Hermitian{â„‚,Matrix{â„‚}},
        Ïˆ ::Vector{â„‚}              ) ::â„   where{EVO<:Evolution_t}
```
Calls the callable of the given Evolution object, `ev`.
"""
function evf(ğ‘¥  ::Rad_per_Î¼s_t{â„š},
             ev ::EVO
             ;
             Ï• ::Vector{â„‚},
             R ::Hermitian{â„‚,Matrix{â„‚}},
             Ïˆ ::Vector{â„‚}              ) ::â„   where{EVO<:Evolution_t}

        1 - 2â‹…absÂ²( ev(x; Ï•,R,Ïˆ, kwargs...) )
end

#----------------------------------------------------------------------------------------------------#
#                                                                                                    #
#----------------------------------------------------------------------------------------------------#


function evf_Î©(ğ›º  ::Rad_per_Î¼s_t
               ;
               ğ›¥   ::Rad_per_Î¼s_t,
               Ï•  ::Vector{â„‚},
               R  ::Hermitian{â„‚,Matrix{â„‚}},
               Ïˆ  ::Vector{â„‚},
               Îµ  ::â„,
               hw ::HW_Descr              ) ::â„

	(; ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›, ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™, ğ‘¡áµ£â‚‘â‚›,ğ‘¡â‚˜â‚â‚“) = get_hw_data(hw)
	(;ğ›¥ğ‘¡â‚˜áµ¢â‚™) = hw

	evf(Ï•,R,Ïˆ ; ğ›º, ğ›¥,
	 	Î©_ğ‘¡áµ’â¿=ğ›¥ğ‘¡â‚˜áµ¢â‚™, Î©_ğ‘¡áµ’á¶ á¶ =ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,
	 	Î”_ğ‘¡áµ’â¿=ğ›¥ğ‘¡â‚˜áµ¢â‚™, Î”_ğ‘¡áµ’á¶ á¶ =ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“-get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º(hw;ğ›º=ğ›ºâ‚˜â‚â‚“, ğ›¥),
	 	ğ‘‡=ğ‘¡â‚˜â‚â‚“,
        Îµ,
	 	hw)
end

function evf_Î”(ğ›¥  ::Rad_per_Î¼s_t
               ;
               ğ›º  ::Rad_per_Î¼s_t,
               Ï•  ::Vector{â„‚},
               R  ::Hermitian{â„‚,Matrix{â„‚}},
               Ïˆ  ::Vector{â„‚},
               Îµ  ::â„,
               hw ::HW_Descr              ) ::â„
    (; ğ›ºâ‚˜â‚â‚“,ğ›ºáµ£â‚‘â‚›, ğ›¥â‚˜â‚â‚“,ğ›¥áµ£â‚‘â‚›, ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,ğ‘¡áµ’â¿_ğ‘¡áµ’á¶ á¶ â‚˜áµ¢â‚™, ğ‘¡áµ£â‚‘â‚›,ğ‘¡â‚˜â‚â‚“) = get_hw_data(hw)
	(;ğ›¥ğ‘¡â‚˜áµ¢â‚™) = hw

    evf(Ï•,R,Ïˆ ; ğ›º, ğ›¥,
	 	Î©_ğ‘¡áµ’â¿=ğ›¥ğ‘¡â‚˜áµ¢â‚™, Î©_ğ‘¡áµ’á¶ á¶ =ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“+get_hw_ğ‘¡áµ’á¶ á¶ â»áµˆâ±á¶ á¶ ğ›¥ğ›º(hw;ğ›º, ğ›¥=ğ›¥â‚˜â‚â‚“),
	 	Î”_ğ‘¡áµ’â¿=ğ›¥ğ‘¡â‚˜áµ¢â‚™, Î”_ğ‘¡áµ’á¶ á¶ =ğ‘¡áµ’á¶ á¶ â‚˜â‚â‚“,
	 	ğ‘‡=ğ‘¡â‚˜â‚â‚“,
        Îµ,
	 	hw)
end


end #^ module DOT_RydSimDeriv
# EOF
